---
title: 패딩
---

### 컨볼루션 연산의 행렬

- $n\times n$ 의 이미지에 $f\times f$ 크기의 필터를 컨볼루션 연산 했을 때 결과의 크기는
 $(n-f+1)\times (n-f+1)$ 이다.
- 즉 연산을 계속 할수록 이미지가 줄어들게 되고 이는 단점으로 작용할 수 있다.
- 이미지 구석에 있는 픽셀은 하나의 필터와만 연산되므로 정보가 버려진다.

- 이런 단점이 있기 떄문에 패딩 기술을 도입한다.
- 기존 이미지에 테두리 한 겹을 덧대어 연산 결과 행렬 크기를 조정할 수 있다.

```python
padding_amount = 1
data = np.array([
    [0, 0, 0, 10, 10, 10],
    [0, 0, 0, 10, 10, 10],
    [0, 0, 0, 10, 10, 10],
    [0, 0, 0, 10, 10, 10],
    [0, 0, 0, 10, 10, 10],
    [0, 0, 0, 10, 10, 10]
])

data = np.pad(data, padding_amount, 'constant', constant_values=0)

# now data is
# [[ 0  0  0  0  0  0  0  0]
#  [ 0  0  0  0 10 10 10  0]
#  [ 0  0  0  0 10 10 10  0]
#  [ 0  0  0  0 10 10 10  0]
#  [ 0  0  0  0 10 10 10  0]
#  [ 0  0  0  0 10 10 10  0]
#  [ 0  0  0  0 10 10 10  0]
#  [ 0  0  0  0  0  0  0  0]]

kernel = np.array([
    [1, 0, -1],
    [1, 0, -1],
    [1, 0, -1]
])

result = conv2d(data, kernel)
print(result)

```

- Valid Convolution: 패딩을 하지 않고 컨볼브 하는 것
- Same Convolution: 패딩을 통해 입력 데이터와 결과 데이터의 크기를 같게하여 컨볼브 하는 것
    - $n+2p-f+1=n$
    - $p=\frac{f-1}{2}$
- $f$ 는 거의 모든 곳에서 홀수임